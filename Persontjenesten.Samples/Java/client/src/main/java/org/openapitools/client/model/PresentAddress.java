/*
 * Persontjenesten API - ET
 * The Person API provides information on norwegian citizens for the norwegian public health sector, and is maintained by [Norsk helsenett](https://www.nhn.no/).  An API changelog is available [here](../static/changelog/index.html).  For more documentation and a complete integration guide, see the [NHN developer portal](https://utviklerportal.nhn.no/informasjonstjenester/persontjenesten/). 
 *
 * The version of the OpenAPI document: 2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.AddressConfidentiality;
import org.openapitools.client.model.ForeignContactAddressForeignAddress;
import org.openapitools.client.model.PresentAddressCadastralAddress;
import org.openapitools.client.model.PresentAddressStreetAddress;
import org.openapitools.client.model.StayElsewhere;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;br&gt;Freg: Oppholdsadresse
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-05-30T07:50:48.244395087Z[Etc/UTC]", comments = "Generator version: 7.7.0-SNAPSHOT")
public class PresentAddress {
  public static final String SERIALIZED_NAME_REGISTERED_AT = "registeredAt";
  @SerializedName(SERIALIZED_NAME_REGISTERED_AT)
  private OffsetDateTime registeredAt;

  public static final String SERIALIZED_NAME_IS_VALID = "isValid";
  @SerializedName(SERIALIZED_NAME_IS_VALID)
  private Boolean isValid;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private String source;

  public static final String SERIALIZED_NAME_REASON = "reason";
  @SerializedName(SERIALIZED_NAME_REASON)
  private String reason;

  public static final String SERIALIZED_NAME_VALID_FROM = "validFrom";
  @SerializedName(SERIALIZED_NAME_VALID_FROM)
  private OffsetDateTime validFrom;

  public static final String SERIALIZED_NAME_VALID_TO = "validTo";
  @SerializedName(SERIALIZED_NAME_VALID_TO)
  private OffsetDateTime validTo;

  public static final String SERIALIZED_NAME_FOREIGN_ADDRESS = "foreignAddress";
  @SerializedName(SERIALIZED_NAME_FOREIGN_ADDRESS)
  private ForeignContactAddressForeignAddress foreignAddress;

  public static final String SERIALIZED_NAME_IS_ADDRESS_UNKNOWN = "isAddressUnknown";
  @SerializedName(SERIALIZED_NAME_IS_ADDRESS_UNKNOWN)
  private Boolean isAddressUnknown;

  public static final String SERIALIZED_NAME_STREET_ADDRESS = "streetAddress";
  @SerializedName(SERIALIZED_NAME_STREET_ADDRESS)
  private PresentAddressStreetAddress streetAddress;

  public static final String SERIALIZED_NAME_CADASTRAL_ADDRESS = "cadastralAddress";
  @SerializedName(SERIALIZED_NAME_CADASTRAL_ADDRESS)
  private PresentAddressCadastralAddress cadastralAddress;

  public static final String SERIALIZED_NAME_CADASTRAL_IDENTIFIER = "cadastralIdentifier";
  @SerializedName(SERIALIZED_NAME_CADASTRAL_IDENTIFIER)
  private String cadastralIdentifier;

  public static final String SERIALIZED_NAME_ADDRESS_CONFIDENTIALITY = "addressConfidentiality";
  @SerializedName(SERIALIZED_NAME_ADDRESS_CONFIDENTIALITY)
  private AddressConfidentiality addressConfidentiality;

  public static final String SERIALIZED_NAME_PRESENT_ADDRESS_DATE = "presentAddressDate";
  @SerializedName(SERIALIZED_NAME_PRESENT_ADDRESS_DATE)
  private OffsetDateTime presentAddressDate;

  public static final String SERIALIZED_NAME_STAY_ELSEWHERE = "stayElsewhere";
  @SerializedName(SERIALIZED_NAME_STAY_ELSEWHERE)
  private StayElsewhere stayElsewhere;

  public static final String SERIALIZED_NAME_URBAN_DISTRICT_CODE = "urbanDistrictCode";
  @SerializedName(SERIALIZED_NAME_URBAN_DISTRICT_CODE)
  private String urbanDistrictCode;

  public static final String SERIALIZED_NAME_URBAN_DISTRICT_NAME = "urbanDistrictName";
  @SerializedName(SERIALIZED_NAME_URBAN_DISTRICT_NAME)
  private String urbanDistrictName;

  public static final String SERIALIZED_NAME_GEOGRAPHICAL_URBAN_DISTRICT_CODE = "geographicalUrbanDistrictCode";
  @SerializedName(SERIALIZED_NAME_GEOGRAPHICAL_URBAN_DISTRICT_CODE)
  private String geographicalUrbanDistrictCode;

  public static final String SERIALIZED_NAME_GEOGRAPHICAL_URBAN_DISTRICT_NAME = "geographicalUrbanDistrictName";
  @SerializedName(SERIALIZED_NAME_GEOGRAPHICAL_URBAN_DISTRICT_NAME)
  private String geographicalUrbanDistrictName;

  public static final String SERIALIZED_NAME_BASIC_STATISTICAL_UNIT = "basicStatisticalUnit";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_BASIC_STATISTICAL_UNIT)
  private Long basicStatisticalUnit;

  public static final String SERIALIZED_NAME_FULL_BASIC_STATISTICAL_UNIT_NUMBER = "fullBasicStatisticalUnitNumber";
  @SerializedName(SERIALIZED_NAME_FULL_BASIC_STATISTICAL_UNIT_NUMBER)
  private String fullBasicStatisticalUnitNumber;

  public static final String SERIALIZED_NAME_BASIC_STATISTICAL_UNIT_NAME = "basicStatisticalUnitName";
  @SerializedName(SERIALIZED_NAME_BASIC_STATISTICAL_UNIT_NAME)
  private String basicStatisticalUnitName;

  public PresentAddress() {
  }

  public PresentAddress registeredAt(OffsetDateTime registeredAt) {
    this.registeredAt = registeredAt;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Ajourholdstidspunkt
   * @return registeredAt
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getRegisteredAt() {
    return registeredAt;
  }

  public void setRegisteredAt(OffsetDateTime registeredAt) {
    this.registeredAt = registeredAt;
  }


  public PresentAddress isValid(Boolean isValid) {
    this.isValid = isValid;
    return this;
  }

   /**
   * &lt;br&gt;FREG: ErGjeldende
   * @return isValid
  **/
  @javax.annotation.Nullable
  public Boolean getIsValid() {
    return isValid;
  }

  public void setIsValid(Boolean isValid) {
    this.isValid = isValid;
  }


  public PresentAddress source(String source) {
    this.source = source;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Kilde
   * @return source
  **/
  @javax.annotation.Nullable
  public String getSource() {
    return source;
  }

  public void setSource(String source) {
    this.source = source;
  }


  public PresentAddress reason(String reason) {
    this.reason = reason;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Aarsak
   * @return reason
  **/
  @javax.annotation.Nullable
  public String getReason() {
    return reason;
  }

  public void setReason(String reason) {
    this.reason = reason;
  }


  public PresentAddress validFrom(OffsetDateTime validFrom) {
    this.validFrom = validFrom;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Gyldighetstidspunkt
   * @return validFrom
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getValidFrom() {
    return validFrom;
  }

  public void setValidFrom(OffsetDateTime validFrom) {
    this.validFrom = validFrom;
  }


  public PresentAddress validTo(OffsetDateTime validTo) {
    this.validTo = validTo;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Opphoerstidspunkt
   * @return validTo
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getValidTo() {
    return validTo;
  }

  public void setValidTo(OffsetDateTime validTo) {
    this.validTo = validTo;
  }


  public PresentAddress foreignAddress(ForeignContactAddressForeignAddress foreignAddress) {
    this.foreignAddress = foreignAddress;
    return this;
  }

   /**
   * Get foreignAddress
   * @return foreignAddress
  **/
  @javax.annotation.Nullable
  public ForeignContactAddressForeignAddress getForeignAddress() {
    return foreignAddress;
  }

  public void setForeignAddress(ForeignContactAddressForeignAddress foreignAddress) {
    this.foreignAddress = foreignAddress;
  }


  public PresentAddress isAddressUnknown(Boolean isAddressUnknown) {
    this.isAddressUnknown = isAddressUnknown;
    return this;
  }

   /**
   * &lt;br&gt;FREG: AdressenErUkjent
   * @return isAddressUnknown
  **/
  @javax.annotation.Nullable
  public Boolean getIsAddressUnknown() {
    return isAddressUnknown;
  }

  public void setIsAddressUnknown(Boolean isAddressUnknown) {
    this.isAddressUnknown = isAddressUnknown;
  }


  public PresentAddress streetAddress(PresentAddressStreetAddress streetAddress) {
    this.streetAddress = streetAddress;
    return this;
  }

   /**
   * Get streetAddress
   * @return streetAddress
  **/
  @javax.annotation.Nullable
  public PresentAddressStreetAddress getStreetAddress() {
    return streetAddress;
  }

  public void setStreetAddress(PresentAddressStreetAddress streetAddress) {
    this.streetAddress = streetAddress;
  }


  public PresentAddress cadastralAddress(PresentAddressCadastralAddress cadastralAddress) {
    this.cadastralAddress = cadastralAddress;
    return this;
  }

   /**
   * Get cadastralAddress
   * @return cadastralAddress
  **/
  @javax.annotation.Nullable
  public PresentAddressCadastralAddress getCadastralAddress() {
    return cadastralAddress;
  }

  public void setCadastralAddress(PresentAddressCadastralAddress cadastralAddress) {
    this.cadastralAddress = cadastralAddress;
  }


  public PresentAddress cadastralIdentifier(String cadastralIdentifier) {
    this.cadastralIdentifier = cadastralIdentifier;
    return this;
  }

   /**
   * Unique identifier from the Norwegian Mapping Authority.  &lt;br&gt;FREG: AdresseIdentifikatorFraMatrikkelen
   * @return cadastralIdentifier
  **/
  @javax.annotation.Nullable
  public String getCadastralIdentifier() {
    return cadastralIdentifier;
  }

  public void setCadastralIdentifier(String cadastralIdentifier) {
    this.cadastralIdentifier = cadastralIdentifier;
  }


  public PresentAddress addressConfidentiality(AddressConfidentiality addressConfidentiality) {
    this.addressConfidentiality = addressConfidentiality;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Adressegradering
   * @return addressConfidentiality
  **/
  @javax.annotation.Nullable
  public AddressConfidentiality getAddressConfidentiality() {
    return addressConfidentiality;
  }

  public void setAddressConfidentiality(AddressConfidentiality addressConfidentiality) {
    this.addressConfidentiality = addressConfidentiality;
  }


  public PresentAddress presentAddressDate(OffsetDateTime presentAddressDate) {
    this.presentAddressDate = presentAddressDate;
    return this;
  }

   /**
   * The date of when this living address was reported to the National Population Register (FREG).  &lt;br&gt;FREG: Oppholdsadressedato
   * @return presentAddressDate
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getPresentAddressDate() {
    return presentAddressDate;
  }

  public void setPresentAddressDate(OffsetDateTime presentAddressDate) {
    this.presentAddressDate = presentAddressDate;
  }


  public PresentAddress stayElsewhere(StayElsewhere stayElsewhere) {
    this.stayElsewhere = stayElsewhere;
    return this;
  }

   /**
   * &lt;br&gt;FREG: OppholdAnnetSted
   * @return stayElsewhere
  **/
  @javax.annotation.Nullable
  public StayElsewhere getStayElsewhere() {
    return stayElsewhere;
  }

  public void setStayElsewhere(StayElsewhere stayElsewhere) {
    this.stayElsewhere = stayElsewhere;
  }


  public PresentAddress urbanDistrictCode(String urbanDistrictCode) {
    this.urbanDistrictCode = urbanDistrictCode;
    return this;
  }

   /**
   * Six digit code for the urban district that provide municipal health- and social services for the address.  Service providing districts are defined by the city, but only Oslo Kommune  has a classification that differs from the geographical classification defined by SSB.  Urban districts are only used in Oslo, Bergen, Stavanger and Trondheim.
   * @return urbanDistrictCode
  **/
  @javax.annotation.Nullable
  public String getUrbanDistrictCode() {
    return urbanDistrictCode;
  }

  public void setUrbanDistrictCode(String urbanDistrictCode) {
    this.urbanDistrictCode = urbanDistrictCode;
  }


  public PresentAddress urbanDistrictName(String urbanDistrictName) {
    this.urbanDistrictName = urbanDistrictName;
    return this;
  }

   /**
   * The name of the service providing urban district.  &lt;br&gt;SSB: Bydelsnavn
   * @return urbanDistrictName
  **/
  @javax.annotation.Nullable
  public String getUrbanDistrictName() {
    return urbanDistrictName;
  }

  public void setUrbanDistrictName(String urbanDistrictName) {
    this.urbanDistrictName = urbanDistrictName;
  }


  public PresentAddress geographicalUrbanDistrictCode(String geographicalUrbanDistrictCode) {
    this.geographicalUrbanDistrictCode = geographicalUrbanDistrictCode;
    return this;
  }

   /**
   * Six digit code for the geographical urban district the address belongs to.  Urban districts are only used in Oslo, Bergen, Stavanger and Trondheim.  Geographical urban districts are defined by SSB in classification 103.  !:https://www.ssb.no/klass/klassifikasjoner/103&lt;br&gt;SSB: Bydelskode
   * @return geographicalUrbanDistrictCode
  **/
  @javax.annotation.Nullable
  public String getGeographicalUrbanDistrictCode() {
    return geographicalUrbanDistrictCode;
  }

  public void setGeographicalUrbanDistrictCode(String geographicalUrbanDistrictCode) {
    this.geographicalUrbanDistrictCode = geographicalUrbanDistrictCode;
  }


  public PresentAddress geographicalUrbanDistrictName(String geographicalUrbanDistrictName) {
    this.geographicalUrbanDistrictName = geographicalUrbanDistrictName;
    return this;
  }

   /**
   * The name of the geographical urban district  &lt;br&gt;SSB: Bydelsnavn
   * @return geographicalUrbanDistrictName
  **/
  @javax.annotation.Nullable
  public String getGeographicalUrbanDistrictName() {
    return geographicalUrbanDistrictName;
  }

  public void setGeographicalUrbanDistrictName(String geographicalUrbanDistrictName) {
    this.geographicalUrbanDistrictName = geographicalUrbanDistrictName;
  }


  @Deprecated
  public PresentAddress basicStatisticalUnit(Long basicStatisticalUnit) {
    this.basicStatisticalUnit = basicStatisticalUnit;
    return this;
  }

   /**
   * Three to four digit code used to divide a municipality in small, stable geographical units,  used as basis for regional statistical analysis.  Should be interpreted as a four digit string with leading zero.  Value 401 means \&quot;0401\&quot; and so on. For present addresses, the basic statistical unit  is enriched by the Person API, derived from the street or cadastral address.
   * @return basicStatisticalUnit
   * @deprecated
  **/
  @Deprecated
  @javax.annotation.Nullable
  public Long getBasicStatisticalUnit() {
    return basicStatisticalUnit;
  }

  @Deprecated
  public void setBasicStatisticalUnit(Long basicStatisticalUnit) {
    this.basicStatisticalUnit = basicStatisticalUnit;
  }


  public PresentAddress fullBasicStatisticalUnitNumber(String fullBasicStatisticalUnitNumber) {
    this.fullBasicStatisticalUnitNumber = fullBasicStatisticalUnitNumber;
    return this;
  }

   /**
   * Eight digit code used to divide a municipality in small, stable geographical units,  used as basis for regional statistical analysis.  The first four digits are the municipality number,  followed by four digits with leading zero identifying the area.  For present addresses, the basic statistical unit  is enriched by the Person API, attempted to be derived from the street or cadastral address  using data from Kartverket (Matrikkelen).  Basic statistical units are defined by SSB in classification 1.  !:https://www.ssb.no/klass/klassifikasjoner/1&lt;br&gt;SSB: Grunnkretsnummer
   * @return fullBasicStatisticalUnitNumber
  **/
  @javax.annotation.Nullable
  public String getFullBasicStatisticalUnitNumber() {
    return fullBasicStatisticalUnitNumber;
  }

  public void setFullBasicStatisticalUnitNumber(String fullBasicStatisticalUnitNumber) {
    this.fullBasicStatisticalUnitNumber = fullBasicStatisticalUnitNumber;
  }


  public PresentAddress basicStatisticalUnitName(String basicStatisticalUnitName) {
    this.basicStatisticalUnitName = basicStatisticalUnitName;
    return this;
  }

   /**
   * The name of the basic statistical unit.  &lt;br&gt;SSB: BasicStatisticalUnitName
   * @return basicStatisticalUnitName
  **/
  @javax.annotation.Nullable
  public String getBasicStatisticalUnitName() {
    return basicStatisticalUnitName;
  }

  public void setBasicStatisticalUnitName(String basicStatisticalUnitName) {
    this.basicStatisticalUnitName = basicStatisticalUnitName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PresentAddress presentAddress = (PresentAddress) o;
    return Objects.equals(this.registeredAt, presentAddress.registeredAt) &&
        Objects.equals(this.isValid, presentAddress.isValid) &&
        Objects.equals(this.source, presentAddress.source) &&
        Objects.equals(this.reason, presentAddress.reason) &&
        Objects.equals(this.validFrom, presentAddress.validFrom) &&
        Objects.equals(this.validTo, presentAddress.validTo) &&
        Objects.equals(this.foreignAddress, presentAddress.foreignAddress) &&
        Objects.equals(this.isAddressUnknown, presentAddress.isAddressUnknown) &&
        Objects.equals(this.streetAddress, presentAddress.streetAddress) &&
        Objects.equals(this.cadastralAddress, presentAddress.cadastralAddress) &&
        Objects.equals(this.cadastralIdentifier, presentAddress.cadastralIdentifier) &&
        Objects.equals(this.addressConfidentiality, presentAddress.addressConfidentiality) &&
        Objects.equals(this.presentAddressDate, presentAddress.presentAddressDate) &&
        Objects.equals(this.stayElsewhere, presentAddress.stayElsewhere) &&
        Objects.equals(this.urbanDistrictCode, presentAddress.urbanDistrictCode) &&
        Objects.equals(this.urbanDistrictName, presentAddress.urbanDistrictName) &&
        Objects.equals(this.geographicalUrbanDistrictCode, presentAddress.geographicalUrbanDistrictCode) &&
        Objects.equals(this.geographicalUrbanDistrictName, presentAddress.geographicalUrbanDistrictName) &&
        Objects.equals(this.basicStatisticalUnit, presentAddress.basicStatisticalUnit) &&
        Objects.equals(this.fullBasicStatisticalUnitNumber, presentAddress.fullBasicStatisticalUnitNumber) &&
        Objects.equals(this.basicStatisticalUnitName, presentAddress.basicStatisticalUnitName);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(registeredAt, isValid, source, reason, validFrom, validTo, foreignAddress, isAddressUnknown, streetAddress, cadastralAddress, cadastralIdentifier, addressConfidentiality, presentAddressDate, stayElsewhere, urbanDistrictCode, urbanDistrictName, geographicalUrbanDistrictCode, geographicalUrbanDistrictName, basicStatisticalUnit, fullBasicStatisticalUnitNumber, basicStatisticalUnitName);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PresentAddress {\n");
    sb.append("    registeredAt: ").append(toIndentedString(registeredAt)).append("\n");
    sb.append("    isValid: ").append(toIndentedString(isValid)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    reason: ").append(toIndentedString(reason)).append("\n");
    sb.append("    validFrom: ").append(toIndentedString(validFrom)).append("\n");
    sb.append("    validTo: ").append(toIndentedString(validTo)).append("\n");
    sb.append("    foreignAddress: ").append(toIndentedString(foreignAddress)).append("\n");
    sb.append("    isAddressUnknown: ").append(toIndentedString(isAddressUnknown)).append("\n");
    sb.append("    streetAddress: ").append(toIndentedString(streetAddress)).append("\n");
    sb.append("    cadastralAddress: ").append(toIndentedString(cadastralAddress)).append("\n");
    sb.append("    cadastralIdentifier: ").append(toIndentedString(cadastralIdentifier)).append("\n");
    sb.append("    addressConfidentiality: ").append(toIndentedString(addressConfidentiality)).append("\n");
    sb.append("    presentAddressDate: ").append(toIndentedString(presentAddressDate)).append("\n");
    sb.append("    stayElsewhere: ").append(toIndentedString(stayElsewhere)).append("\n");
    sb.append("    urbanDistrictCode: ").append(toIndentedString(urbanDistrictCode)).append("\n");
    sb.append("    urbanDistrictName: ").append(toIndentedString(urbanDistrictName)).append("\n");
    sb.append("    geographicalUrbanDistrictCode: ").append(toIndentedString(geographicalUrbanDistrictCode)).append("\n");
    sb.append("    geographicalUrbanDistrictName: ").append(toIndentedString(geographicalUrbanDistrictName)).append("\n");
    sb.append("    basicStatisticalUnit: ").append(toIndentedString(basicStatisticalUnit)).append("\n");
    sb.append("    fullBasicStatisticalUnitNumber: ").append(toIndentedString(fullBasicStatisticalUnitNumber)).append("\n");
    sb.append("    basicStatisticalUnitName: ").append(toIndentedString(basicStatisticalUnitName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("registeredAt");
    openapiFields.add("isValid");
    openapiFields.add("source");
    openapiFields.add("reason");
    openapiFields.add("validFrom");
    openapiFields.add("validTo");
    openapiFields.add("foreignAddress");
    openapiFields.add("isAddressUnknown");
    openapiFields.add("streetAddress");
    openapiFields.add("cadastralAddress");
    openapiFields.add("cadastralIdentifier");
    openapiFields.add("addressConfidentiality");
    openapiFields.add("presentAddressDate");
    openapiFields.add("stayElsewhere");
    openapiFields.add("urbanDistrictCode");
    openapiFields.add("urbanDistrictName");
    openapiFields.add("geographicalUrbanDistrictCode");
    openapiFields.add("geographicalUrbanDistrictName");
    openapiFields.add("basicStatisticalUnit");
    openapiFields.add("fullBasicStatisticalUnitNumber");
    openapiFields.add("basicStatisticalUnitName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to PresentAddress
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PresentAddress.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PresentAddress is not found in the empty JSON string", PresentAddress.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PresentAddress.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PresentAddress` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) && !jsonObj.get("source").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `source` to be a primitive type in the JSON string but got `%s`", jsonObj.get("source").toString()));
      }
      if ((jsonObj.get("reason") != null && !jsonObj.get("reason").isJsonNull()) && !jsonObj.get("reason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reason").toString()));
      }
      // validate the optional field `foreignAddress`
      if (jsonObj.get("foreignAddress") != null && !jsonObj.get("foreignAddress").isJsonNull()) {
        ForeignContactAddressForeignAddress.validateJsonElement(jsonObj.get("foreignAddress"));
      }
      // validate the optional field `streetAddress`
      if (jsonObj.get("streetAddress") != null && !jsonObj.get("streetAddress").isJsonNull()) {
        PresentAddressStreetAddress.validateJsonElement(jsonObj.get("streetAddress"));
      }
      // validate the optional field `cadastralAddress`
      if (jsonObj.get("cadastralAddress") != null && !jsonObj.get("cadastralAddress").isJsonNull()) {
        PresentAddressCadastralAddress.validateJsonElement(jsonObj.get("cadastralAddress"));
      }
      if ((jsonObj.get("cadastralIdentifier") != null && !jsonObj.get("cadastralIdentifier").isJsonNull()) && !jsonObj.get("cadastralIdentifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cadastralIdentifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cadastralIdentifier").toString()));
      }
      // validate the optional field `addressConfidentiality`
      if (jsonObj.get("addressConfidentiality") != null && !jsonObj.get("addressConfidentiality").isJsonNull()) {
        AddressConfidentiality.validateJsonElement(jsonObj.get("addressConfidentiality"));
      }
      // validate the optional field `stayElsewhere`
      if (jsonObj.get("stayElsewhere") != null && !jsonObj.get("stayElsewhere").isJsonNull()) {
        StayElsewhere.validateJsonElement(jsonObj.get("stayElsewhere"));
      }
      if ((jsonObj.get("urbanDistrictCode") != null && !jsonObj.get("urbanDistrictCode").isJsonNull()) && !jsonObj.get("urbanDistrictCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `urbanDistrictCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("urbanDistrictCode").toString()));
      }
      if ((jsonObj.get("urbanDistrictName") != null && !jsonObj.get("urbanDistrictName").isJsonNull()) && !jsonObj.get("urbanDistrictName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `urbanDistrictName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("urbanDistrictName").toString()));
      }
      if ((jsonObj.get("geographicalUrbanDistrictCode") != null && !jsonObj.get("geographicalUrbanDistrictCode").isJsonNull()) && !jsonObj.get("geographicalUrbanDistrictCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `geographicalUrbanDistrictCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("geographicalUrbanDistrictCode").toString()));
      }
      if ((jsonObj.get("geographicalUrbanDistrictName") != null && !jsonObj.get("geographicalUrbanDistrictName").isJsonNull()) && !jsonObj.get("geographicalUrbanDistrictName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `geographicalUrbanDistrictName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("geographicalUrbanDistrictName").toString()));
      }
      if ((jsonObj.get("fullBasicStatisticalUnitNumber") != null && !jsonObj.get("fullBasicStatisticalUnitNumber").isJsonNull()) && !jsonObj.get("fullBasicStatisticalUnitNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fullBasicStatisticalUnitNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fullBasicStatisticalUnitNumber").toString()));
      }
      if ((jsonObj.get("basicStatisticalUnitName") != null && !jsonObj.get("basicStatisticalUnitName").isJsonNull()) && !jsonObj.get("basicStatisticalUnitName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `basicStatisticalUnitName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("basicStatisticalUnitName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PresentAddress.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PresentAddress' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PresentAddress> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PresentAddress.class));

       return (TypeAdapter<T>) new TypeAdapter<PresentAddress>() {
           @Override
           public void write(JsonWriter out, PresentAddress value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PresentAddress read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of PresentAddress given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of PresentAddress
  * @throws IOException if the JSON string is invalid with respect to PresentAddress
  */
  public static PresentAddress fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PresentAddress.class);
  }

 /**
  * Convert an instance of PresentAddress to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

