/*
 * Persontjenesten API - ET
 * The Person API provides information on norwegian citizens for the norwegian public health sector, and is maintained by [Norsk helsenett](https://www.nhn.no/).  An API changelog is available [here](../static/changelog/index.html).  For more documentation and a complete integration guide, see the [NHN developer portal](https://utviklerportal.nhn.no/informasjonstjenester/persontjenesten/). 
 *
 * The version of the OpenAPI document: 2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.FalseIdentityCorrectIdentityFromInformation;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Information regarding false identity on a person  An identity belonging to another person then the person using it.  Or not belonging to anyone at all, but presented as a real identity                Persons who is currently or have had their NIN (Norwegian Identification Number)  misused by others, will not have information about the misuse.  Neither will there be info on the person misusing another persons identity.  &lt;br&gt;FREG: FalskIdentitet
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-05-30T07:50:48.244395087Z[Etc/UTC]", comments = "Generator version: 7.7.0-SNAPSHOT")
public class FalseIdentity {
  public static final String SERIALIZED_NAME_REGISTERED_AT = "registeredAt";
  @SerializedName(SERIALIZED_NAME_REGISTERED_AT)
  private OffsetDateTime registeredAt;

  public static final String SERIALIZED_NAME_IS_VALID = "isValid";
  @SerializedName(SERIALIZED_NAME_IS_VALID)
  private Boolean isValid;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private String source;

  public static final String SERIALIZED_NAME_REASON = "reason";
  @SerializedName(SERIALIZED_NAME_REASON)
  private String reason;

  public static final String SERIALIZED_NAME_VALID_FROM = "validFrom";
  @SerializedName(SERIALIZED_NAME_VALID_FROM)
  private OffsetDateTime validFrom;

  public static final String SERIALIZED_NAME_VALID_TO = "validTo";
  @SerializedName(SERIALIZED_NAME_VALID_TO)
  private OffsetDateTime validTo;

  public static final String SERIALIZED_NAME_CORRECT_IDENTITY_FROM_INFORMATION = "correctIdentityFromInformation";
  @SerializedName(SERIALIZED_NAME_CORRECT_IDENTITY_FROM_INFORMATION)
  private FalseIdentityCorrectIdentityFromInformation correctIdentityFromInformation;

  public static final String SERIALIZED_NAME_IS_CORRECT_IDENTITY_UNKNOWN = "isCorrectIdentityUnknown";
  @SerializedName(SERIALIZED_NAME_IS_CORRECT_IDENTITY_UNKNOWN)
  private Boolean isCorrectIdentityUnknown;

  public static final String SERIALIZED_NAME_CORRECT_IDENTITY_FROM_IDENTIFICATION_NUMBER = "correctIdentityFromIdentificationNumber";
  @SerializedName(SERIALIZED_NAME_CORRECT_IDENTITY_FROM_IDENTIFICATION_NUMBER)
  private String correctIdentityFromIdentificationNumber;

  public static final String SERIALIZED_NAME_IS_FALSE_IDENTITY = "isFalseIdentity";
  @SerializedName(SERIALIZED_NAME_IS_FALSE_IDENTITY)
  private Boolean isFalseIdentity;

  public FalseIdentity() {
  }

  public FalseIdentity registeredAt(OffsetDateTime registeredAt) {
    this.registeredAt = registeredAt;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Ajourholdstidspunkt
   * @return registeredAt
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getRegisteredAt() {
    return registeredAt;
  }

  public void setRegisteredAt(OffsetDateTime registeredAt) {
    this.registeredAt = registeredAt;
  }


  public FalseIdentity isValid(Boolean isValid) {
    this.isValid = isValid;
    return this;
  }

   /**
   * &lt;br&gt;FREG: ErGjeldende
   * @return isValid
  **/
  @javax.annotation.Nullable
  public Boolean getIsValid() {
    return isValid;
  }

  public void setIsValid(Boolean isValid) {
    this.isValid = isValid;
  }


  public FalseIdentity source(String source) {
    this.source = source;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Kilde
   * @return source
  **/
  @javax.annotation.Nullable
  public String getSource() {
    return source;
  }

  public void setSource(String source) {
    this.source = source;
  }


  public FalseIdentity reason(String reason) {
    this.reason = reason;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Aarsak
   * @return reason
  **/
  @javax.annotation.Nullable
  public String getReason() {
    return reason;
  }

  public void setReason(String reason) {
    this.reason = reason;
  }


  public FalseIdentity validFrom(OffsetDateTime validFrom) {
    this.validFrom = validFrom;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Gyldighetstidspunkt
   * @return validFrom
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getValidFrom() {
    return validFrom;
  }

  public void setValidFrom(OffsetDateTime validFrom) {
    this.validFrom = validFrom;
  }


  public FalseIdentity validTo(OffsetDateTime validTo) {
    this.validTo = validTo;
    return this;
  }

   /**
   * &lt;br&gt;FREG: Opphoerstidspunkt
   * @return validTo
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getValidTo() {
    return validTo;
  }

  public void setValidTo(OffsetDateTime validTo) {
    this.validTo = validTo;
  }


  public FalseIdentity correctIdentityFromInformation(FalseIdentityCorrectIdentityFromInformation correctIdentityFromInformation) {
    this.correctIdentityFromInformation = correctIdentityFromInformation;
    return this;
  }

   /**
   * Get correctIdentityFromInformation
   * @return correctIdentityFromInformation
  **/
  @javax.annotation.Nullable
  public FalseIdentityCorrectIdentityFromInformation getCorrectIdentityFromInformation() {
    return correctIdentityFromInformation;
  }

  public void setCorrectIdentityFromInformation(FalseIdentityCorrectIdentityFromInformation correctIdentityFromInformation) {
    this.correctIdentityFromInformation = correctIdentityFromInformation;
  }


  public FalseIdentity isCorrectIdentityUnknown(Boolean isCorrectIdentityUnknown) {
    this.isCorrectIdentityUnknown = isCorrectIdentityUnknown;
    return this;
  }

   /**
   * If true, the correct identity for the false identity is not known  &lt;br&gt;FREG: RettIdentitetErUkjent
   * @return isCorrectIdentityUnknown
  **/
  @javax.annotation.Nullable
  public Boolean getIsCorrectIdentityUnknown() {
    return isCorrectIdentityUnknown;
  }

  public void setIsCorrectIdentityUnknown(Boolean isCorrectIdentityUnknown) {
    this.isCorrectIdentityUnknown = isCorrectIdentityUnknown;
  }


  public FalseIdentity correctIdentityFromIdentificationNumber(String correctIdentityFromIdentificationNumber) {
    this.correctIdentityFromIdentificationNumber = correctIdentityFromIdentificationNumber;
    return this;
  }

   /**
   * The correct identity for the false identity  is known by the Norwegian Identification Number (f√∏dselsnummer or D-number)  &lt;br&gt;FREG: RettIdentitetVedIdentifikasjonsnummer
   * @return correctIdentityFromIdentificationNumber
  **/
  @javax.annotation.Nullable
  public String getCorrectIdentityFromIdentificationNumber() {
    return correctIdentityFromIdentificationNumber;
  }

  public void setCorrectIdentityFromIdentificationNumber(String correctIdentityFromIdentificationNumber) {
    this.correctIdentityFromIdentificationNumber = correctIdentityFromIdentificationNumber;
  }


  public FalseIdentity isFalseIdentity(Boolean isFalseIdentity) {
    this.isFalseIdentity = isFalseIdentity;
    return this;
  }

   /**
   * &lt;br&gt;Remarks:               Should always be true              Freg: ErFalsk
   * @return isFalseIdentity
  **/
  @javax.annotation.Nullable
  public Boolean getIsFalseIdentity() {
    return isFalseIdentity;
  }

  public void setIsFalseIdentity(Boolean isFalseIdentity) {
    this.isFalseIdentity = isFalseIdentity;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FalseIdentity falseIdentity = (FalseIdentity) o;
    return Objects.equals(this.registeredAt, falseIdentity.registeredAt) &&
        Objects.equals(this.isValid, falseIdentity.isValid) &&
        Objects.equals(this.source, falseIdentity.source) &&
        Objects.equals(this.reason, falseIdentity.reason) &&
        Objects.equals(this.validFrom, falseIdentity.validFrom) &&
        Objects.equals(this.validTo, falseIdentity.validTo) &&
        Objects.equals(this.correctIdentityFromInformation, falseIdentity.correctIdentityFromInformation) &&
        Objects.equals(this.isCorrectIdentityUnknown, falseIdentity.isCorrectIdentityUnknown) &&
        Objects.equals(this.correctIdentityFromIdentificationNumber, falseIdentity.correctIdentityFromIdentificationNumber) &&
        Objects.equals(this.isFalseIdentity, falseIdentity.isFalseIdentity);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(registeredAt, isValid, source, reason, validFrom, validTo, correctIdentityFromInformation, isCorrectIdentityUnknown, correctIdentityFromIdentificationNumber, isFalseIdentity);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FalseIdentity {\n");
    sb.append("    registeredAt: ").append(toIndentedString(registeredAt)).append("\n");
    sb.append("    isValid: ").append(toIndentedString(isValid)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    reason: ").append(toIndentedString(reason)).append("\n");
    sb.append("    validFrom: ").append(toIndentedString(validFrom)).append("\n");
    sb.append("    validTo: ").append(toIndentedString(validTo)).append("\n");
    sb.append("    correctIdentityFromInformation: ").append(toIndentedString(correctIdentityFromInformation)).append("\n");
    sb.append("    isCorrectIdentityUnknown: ").append(toIndentedString(isCorrectIdentityUnknown)).append("\n");
    sb.append("    correctIdentityFromIdentificationNumber: ").append(toIndentedString(correctIdentityFromIdentificationNumber)).append("\n");
    sb.append("    isFalseIdentity: ").append(toIndentedString(isFalseIdentity)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("registeredAt");
    openapiFields.add("isValid");
    openapiFields.add("source");
    openapiFields.add("reason");
    openapiFields.add("validFrom");
    openapiFields.add("validTo");
    openapiFields.add("correctIdentityFromInformation");
    openapiFields.add("isCorrectIdentityUnknown");
    openapiFields.add("correctIdentityFromIdentificationNumber");
    openapiFields.add("isFalseIdentity");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to FalseIdentity
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FalseIdentity.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FalseIdentity is not found in the empty JSON string", FalseIdentity.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FalseIdentity.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FalseIdentity` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) && !jsonObj.get("source").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `source` to be a primitive type in the JSON string but got `%s`", jsonObj.get("source").toString()));
      }
      if ((jsonObj.get("reason") != null && !jsonObj.get("reason").isJsonNull()) && !jsonObj.get("reason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reason").toString()));
      }
      // validate the optional field `correctIdentityFromInformation`
      if (jsonObj.get("correctIdentityFromInformation") != null && !jsonObj.get("correctIdentityFromInformation").isJsonNull()) {
        FalseIdentityCorrectIdentityFromInformation.validateJsonElement(jsonObj.get("correctIdentityFromInformation"));
      }
      if ((jsonObj.get("correctIdentityFromIdentificationNumber") != null && !jsonObj.get("correctIdentityFromIdentificationNumber").isJsonNull()) && !jsonObj.get("correctIdentityFromIdentificationNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `correctIdentityFromIdentificationNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("correctIdentityFromIdentificationNumber").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FalseIdentity.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FalseIdentity' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FalseIdentity> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FalseIdentity.class));

       return (TypeAdapter<T>) new TypeAdapter<FalseIdentity>() {
           @Override
           public void write(JsonWriter out, FalseIdentity value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FalseIdentity read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FalseIdentity given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FalseIdentity
  * @throws IOException if the JSON string is invalid with respect to FalseIdentity
  */
  public static FalseIdentity fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FalseIdentity.class);
  }

 /**
  * Convert an instance of FalseIdentity to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

